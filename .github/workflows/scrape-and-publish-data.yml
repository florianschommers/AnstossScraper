name: Scrape and publish data

on:
  schedule:
    # Alle 2 Tage um 3:00 UTC
    - cron: '0 3 */2 * *'
  workflow_dispatch:  # Manuell ausl√∂sbar

permissions:
  contents: write

# WICHTIG: Verhindert, dass mehrere Workflows gleichzeitig laufen
concurrency:
  group: scrape-workflows
  cancel-in-progress: false  # Laufende Workflows nicht abbrechen, sondern warten

jobs:
  scrape:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          repository: florianschommers/AnstossScraper
          ref: main
          token: ${{ secrets.ANSTOSS_SCRAPER_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # WICHTIG: Vollst√§ndige Historie f√ºr Git-Operationen
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Dependencies
        run: |
          pip install requests beautifulsoup4
      
      - name: Run Scraper
        run: |
          # Hier dein Scraper-Code
          # python scraper/scrape_data.py
          echo "Scraper w√ºrde hier laufen"
      
      - name: Commit and Push
        env:
          GITHUB_TOKEN: ${{ secrets.ANSTOSS_SCRAPER_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          # Git-Konfiguration (LOCAL, nicht global!)
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          
          # Setze Remote URL mit Token
          REPO_URL="https://${GITHUB_TOKEN}@github.com/florianschommers/AnstossScraper.git"
          git remote set-url origin "$REPO_URL"
          
          # WICHTIG: IMMER zuerst Pull, bevor wir etwas machen!
          echo "üîÑ Schritt 1: Hole neueste √Ñnderungen vom Remote..."
          
          # WICHTIG: Stashe uncommitted √Ñnderungen vor Pull (l√∂st "unstaged changes" Problem)
          echo "üíæ Pr√ºfe auf uncommitted √Ñnderungen..."
          if ! git diff --quiet || ! git diff --cached --quiet; then
            echo "üì¶ Stashe uncommitted √Ñnderungen..."
            git stash push -m "Auto-stash before pull - $(date +'%Y-%m-%d %H:%M:%S UTC')" || true
            STASHED=true
          else
            STASHED=false
          fi
          
          git fetch origin main
          
          # Pr√ºfe ob es Remote-√Ñnderungen gibt
          LOCAL=$(git rev-parse HEAD)
          REMOTE=$(git rev-parse origin/main)
          
          if [ "$LOCAL" != "$REMOTE" ]; then
            echo "üì• Remote hat neue Commits, hole sie..."
            
            # Versuche Rebase (bevorzugt, da es eine saubere Historie beh√§lt)
            if git rebase origin/main; then
              echo "‚úÖ Rebase erfolgreich"
            # Fallback: Merge wenn Rebase fehlschl√§gt
            elif git merge origin/main --no-edit; then
              echo "‚úÖ Merge erfolgreich"
            else
              echo "‚ö†Ô∏è Rebase/Merge fehlgeschlagen, reset auf origin/main..."
              # Bei Konflikten: Reset auf origin/main (verwirft lokale uncommitted √Ñnderungen)
              git reset --hard origin/main
            fi
          else
            echo "‚úÖ Bereits auf neuestem Stand"
          fi
          
          # WICHTIG: Stash wieder anwenden nach erfolgreichem Pull
          if [ "$STASHED" = true ]; then
            echo "üì¶ Wende gestashte √Ñnderungen wieder an..."
            if git stash pop 2>&1; then
              echo "‚úÖ Stash erfolgreich angewendet"
            else
              echo "‚ö†Ô∏è Stash konnte nicht angewendet werden (m√∂glicherweise Konflikte)"
              # Bei Konflikten: Stash behalten, aber fortfahren
              git stash list
            fi
          fi
          
          # Pr√ºfe ob es √Ñnderungen gibt
          echo "üîÑ Schritt 2: Pr√ºfe auf √Ñnderungen..."
          git status
          
          # Add alle √Ñnderungen
          if ! git diff --quiet || ! git diff --cached --quiet; then
            echo "üìù √Ñnderungen gefunden, committe..."
            git add .
            
            # Commit
            git commit -m "Update scraped data" || {
              echo "‚ö†Ô∏è Commit fehlgeschlagen (m√∂glicherweise keine √Ñnderungen)"
              exit 0
            }
            
            # WICHTIG: NOCHMAL Pull vor Push (Race Condition vermeiden)
            # Zwischen Commit und Push k√∂nnten andere Actions neue Commits gemacht haben
            echo "üîÑ Schritt 3: Nochmal Pull vor Push (Race Condition vermeiden)..."
            git fetch origin main
            
            # Pr√ºfe ob Remote neue Commits hat
            LOCAL=$(git rev-parse HEAD)
            REMOTE=$(git rev-parse origin/main)
            
            if [ "$LOCAL" != "$REMOTE" ]; then
              echo "üì• Remote hat neue Commits nach unserem Commit, integriere sie..."
              git rebase origin/main || git merge origin/main --no-edit || {
                echo "‚ö†Ô∏è Rebase/Merge fehlgeschlagen, reset und neu committen..."
                # Bei Konflikten: Reset auf Remote und neu committen
                git reset --hard origin/main
                git add .
                git commit -m "Update scraped data"
              }
            fi
            
            # Push mit Retry-Logik
            echo "üöÄ Schritt 4: Push zu Remote..."
            MAX_PUSH_RETRIES=10
            PUSH_RETRY=0
            PUSH_SUCCESS=false
            
            while [ $PUSH_RETRY -lt $MAX_PUSH_RETRIES ]; do
              echo "üöÄ Push-Versuch $((PUSH_RETRY + 1))/$MAX_PUSH_RETRIES..."
              
              # NOCHMAL Fetch vor jedem Push-Versuch (Race Condition vermeiden)
              git fetch origin main
              
              # Pr√ºfe ob wir hinter Remote sind
              LOCAL=$(git rev-parse HEAD)
              REMOTE=$(git rev-parse origin/main)
              
              if [ "$REMOTE" != "$LOCAL" ]; then
                # Pr√ºfe ob Remote voraus ist (nicht nur divergiert)
                BASE=$(git merge-base HEAD origin/main)
                if [ "$REMOTE" != "$BASE" ]; then
                  echo "‚ö†Ô∏è Remote ist voraus, hole neueste √Ñnderungen..."
                  git rebase origin/main || git merge origin/main --no-edit || {
                    echo "üîÑ Reset und neu committen..."
                    git reset --hard origin/main
                    git add .
                    git commit -m "Update scraped data"
                  }
                fi
              fi
              
              # Push
              PUSH_OUTPUT=$(git push origin HEAD:main 2>&1)
              PUSH_EXIT=$?
              
              if [ $PUSH_EXIT -eq 0 ]; then
                echo "‚úÖ Push erfolgreich!"
                PUSH_SUCCESS=true
                break
              else
                echo "$PUSH_OUTPUT"
                
                # Pr√ºfe ob es ein "rejected" Fehler ist
                if echo "$PUSH_OUTPUT" | grep -q "rejected\|fetch first"; then
                  echo "‚ö†Ô∏è Push abgelehnt - Remote hat neue Commits"
                  PUSH_RETRY=$((PUSH_RETRY + 1))
                  if [ $PUSH_RETRY -lt $MAX_PUSH_RETRIES ]; then
                    WAIT=$((PUSH_RETRY * 3))
                    echo "‚è≥ Warte ${WAIT}s und hole dann neueste √Ñnderungen..."
                    sleep $WAIT
                    
                    # Hole neueste √Ñnderungen und integriere sie
                    git fetch origin main
                    git rebase origin/main || git merge origin/main --no-edit || {
                      echo "üîÑ Reset und neu committen..."
                      git reset --hard origin/main
                      git add .
                      git commit -m "Update scraped data"
                    }
                  fi
                else
                  echo "‚ùå Anderer Fehler beim Push"
                  PUSH_RETRY=$((PUSH_RETRY + 1))
                  if [ $PUSH_RETRY -lt $MAX_PUSH_RETRIES ]; then
                    sleep $((PUSH_RETRY * 2))
                  fi
                fi
              fi
            done
            
            if [ "$PUSH_SUCCESS" = false ]; then
              echo "‚ùå Push fehlgeschlagen nach $MAX_PUSH_RETRIES Versuchen"
              echo "‚ö†Ô∏è Der n√§chste Workflow-Lauf wird es erneut versuchen"
              exit 1
            fi
          else
            echo "‚ÑπÔ∏è Keine √Ñnderungen zum Committen"
          fi

