name: Scrape Matches

on:
  schedule:
    # Alle 5 Minuten (f√ºr Live-Updates)
    - cron: '*/5 * * * *'
    # Zus√§tzliche feste Uhrzeiten (MEZ/MESZ ‚Üí UTC)
    # MEZ (Winter): UTC = MEZ - 1h | MESZ (Sommer): UTC = MESZ - 2h
    # 13:00 MEZ/MESZ ‚Üí 12:00 UTC (Winter) / 11:00 UTC (Sommer)
    - cron: '0 12 * * *'   # 13:00 MEZ / 14:00 MESZ
    - cron: '30 12 * * *'  # 13:30 MEZ / 14:30 MESZ
    - cron: '0 13 * * *'   # 14:00 MEZ / 15:00 MESZ
    - cron: '30 13 * * *'  # 14:30 MEZ / 15:30 MESZ
    - cron: '30 14 * * *'  # 15:30 MEZ / 16:30 MESZ
    - cron: '30 15 * * *'  # 16:30 MEZ / 17:30 MESZ
    - cron: '45 15 * * *'  # 16:45 MEZ / 17:45 MESZ
    - cron: '0 16 * * *'   # 17:00 MEZ / 18:00 MESZ
    - cron: '30 16 * * *'  # 17:30 MEZ / 18:30 MESZ
    - cron: '45 16 * * *'  # 17:45 MEZ / 18:45 MESZ
    - cron: '30 17 * * *'  # 18:30 MEZ / 19:30 MESZ
    - cron: '45 17 * * *'  # 18:45 MEZ / 19:45 MESZ
    - cron: '0 18 * * *'   # 19:00 MEZ / 20:00 MESZ
    - cron: '30 18 * * *'  # 19:30 MEZ / 20:30 MESZ
    - cron: '0 19 * * *'   # 20:00 MEZ / 21:00 MESZ
    - cron: '30 19 * * *'  # 20:30 MEZ / 21:30 MESZ
    - cron: '0 20 * * *'   # 21:00 MEZ / 22:00 MESZ
  workflow_dispatch:  # Manuell ausl√∂sbar

permissions:
  contents: write

# WICHTIG: Verhindert, dass mehrere Workflows gleichzeitig laufen
concurrency:
  group: scrape-workflows
  cancel-in-progress: false  # Laufende Workflows nicht abbrechen, sondern warten

jobs:
  scrape:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          # Explizit das aktuelle Repository verwenden
          repository: ${{ github.repository }}
          ref: main
          token: ${{ secrets.ANSTOSS_SCRAPER_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # Hole vollst√§ndige Historie f√ºr bessere Git-Operationen
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Dependencies
        run: |
          pip install -r scraper/requirements.txt
      
      - name: Run Scraper
        continue-on-error: false
        run: |
          python scraper/scrape_matches.py || {
            echo "‚ö†Ô∏è Scraper beendet mit Fehler, pr√ºfe Logs oben"
            exit 1
          }
      
      - name: Commit and Push
        env:
          GITHUB_TOKEN: ${{ secrets.ANSTOSS_SCRAPER_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Setze Remote URL mit Token f√ºr alle Git-Operationen
          REPO_URL="https://${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"
          git remote set-url origin "$REPO_URL"
          
          # Zeige aktuelle Remote-URL (ohne Token f√ºr Sicherheit)
          echo "üì¶ Repository: ${{ github.repository }}"
          echo "üîó Remote URL gesetzt"
          
          # Pull latest changes first (mit Retry-Logik f√ºr tempor√§re Fehler)
          # WICHTIG: Pull muss erfolgreich sein, bevor wir pushen k√∂nnen
          MAX_RETRIES=5
          RETRY_COUNT=0
          PULL_SUCCESS=false
          
          # WICHTIG: Stashe uncommitted √Ñnderungen vor Pull (l√∂st "unstaged changes" Problem)
          echo "üíæ Pr√ºfe auf uncommitted √Ñnderungen..."
          if ! git diff --quiet || ! git diff --cached --quiet; then
            echo "üì¶ Stashe uncommitted √Ñnderungen..."
            git stash push -m "Auto-stash before pull - $(date +'%Y-%m-%d %H:%M:%S UTC')" || true
            STASHED=true
          else
            STASHED=false
          fi
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "üîÑ Git pull (Versuch $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            
            # Fetch zuerst, um sicherzustellen, dass wir die neuesten √Ñnderungen haben
            if git fetch origin main 2>&1; then
              echo "‚úÖ Git fetch erfolgreich"
              
              # Versuche Rebase (bevorzugt, da es eine saubere Historie beh√§lt)
              if git rebase origin/main 2>&1; then
                echo "‚úÖ Git rebase erfolgreich"
                PULL_SUCCESS=true
                break
              # Fallback: Merge wenn Rebase fehlschl√§gt
              elif git merge origin/main --no-edit 2>&1; then
                echo "‚úÖ Git merge erfolgreich"
                PULL_SUCCESS=true
                break
              else
                echo "‚ö†Ô∏è Rebase/Merge fehlgeschlagen, versuche Reset..."
                # Bei Konflikten: Reset auf origin/main (verwirft lokale √Ñnderungen, die nicht committed sind)
                git reset --hard origin/main 2>&1 || true
                PULL_SUCCESS=true
                break
              fi
            else
              echo "‚ö†Ô∏è Git fetch fehlgeschlagen"
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 3))
              echo "‚è≥ Warte ${WAIT_TIME}s vor erneutem Versuch..."
              sleep $WAIT_TIME
            fi
          done
          
          # WICHTIG: Stash wieder anwenden nach erfolgreichem Pull
          if [ "$STASHED" = true ]; then
            echo "üì¶ Wende gestashte √Ñnderungen wieder an..."
            if git stash pop 2>&1; then
              echo "‚úÖ Stash erfolgreich angewendet"
            else
              echo "‚ö†Ô∏è Stash konnte nicht angewendet werden (m√∂glicherweise Konflikte)"
              # Bei Konflikten: Stash behalten, aber fortfahren
              git stash list
            fi
          fi
          
          if [ "$PULL_SUCCESS" = false ]; then
            echo "‚ùå Git pull fehlgeschlagen nach $MAX_RETRIES Versuchen"
            echo "‚ö†Ô∏è Versuche trotzdem fortzufahren, aber Push k√∂nnte fehlschlagen..."
          fi
          
          # Pr√ºfe ob data/matches Verzeichnis existiert
          if [ ! -d "data/matches" ]; then
            echo "‚ö†Ô∏è Verzeichnis data/matches existiert nicht - erstelle es"
            mkdir -p data/matches
          fi
          
          # Pr√ºfe ob JSON-Dateien vorhanden sind
          if ls data/matches/*.json 1> /dev/null 2>&1; then
            echo "üìÅ Gefundene JSON-Dateien:"
            ls -lh data/matches/*.json
            
            # Add Dateien (mit Fehlerbehandlung)
            if git add data/matches/*.json; then
              echo "‚úÖ Dateien zu Git hinzugef√ºgt"
              
              # Pr√ºfe ob es √Ñnderungen gibt
              if ! git diff --staged --quiet; then
                echo "üìù Committe √Ñnderungen..."
                git commit -m "Update match data - $(date +'%Y-%m-%d %H:%M:%S UTC')" || {
                  echo "‚ö†Ô∏è Commit fehlgeschlagen (m√∂glicherweise keine √Ñnderungen)"
                  exit 0
                }
                
                # Push mit Retry-Logik - bei jedem Versuch Pull vorher
                RETRY_COUNT=0
                PUSH_SUCCESS=false
                MAX_PUSH_RETRIES=10
                
                while [ $RETRY_COUNT -lt $MAX_PUSH_RETRIES ]; do
                  # IMMER vor jedem Push-Versuch: Hole neueste √Ñnderungen
                  echo "üîÑ Hole neueste √Ñnderungen vor Push (Versuch $((RETRY_COUNT + 1))/$MAX_PUSH_RETRIES)..."
                  
                  # Fetch zuerst, um die neuesten √Ñnderungen zu holen
                  if ! git fetch origin main 2>&1; then
                    echo "‚ö†Ô∏è Git fetch fehlgeschlagen, versuche trotzdem zu pushen..."
                  fi
                  
                  # Pr√ºfe ob es lokale Commits gibt, die nicht auf Remote sind
                  LOCAL_COMMITS=$(git rev-list HEAD...origin/main --count 2>/dev/null || echo "0")
                  
                  if [ "$LOCAL_COMMITS" -gt 0 ]; then
                    echo "üìù Gefunden: $LOCAL_COMMITS lokale Commits, die nicht auf Remote sind"
                    
                    # Versuche Rebase (bevorzugt)
                    if git rebase origin/main 2>&1; then
                      echo "‚úÖ Rebase erfolgreich"
                    # Fallback: Merge
                    elif git merge origin/main --no-edit 2>&1; then
                      echo "‚úÖ Merge erfolgreich"
                    else
                      echo "‚ö†Ô∏è Rebase/Merge fehlgeschlagen, versuche Reset und neu committen..."
                      # Bei Konflikten: Reset auf origin/main und neu committen
                      if [ $RETRY_COUNT -lt $((MAX_PUSH_RETRIES - 1)) ]; then
                        echo "üîÑ Reset auf origin/main und neu committen..."
                        git reset --hard origin/main 2>&1
                        # Dateien wieder hinzuf√ºgen und committen
                        git add data/matches/*.json 2>&1
                        git commit -m "Update match data - $(date +'%Y-%m-%d %H:%M:%S UTC')" 2>&1
                      fi
                    fi
                  else
                    echo "‚ÑπÔ∏è Keine lokalen Commits, die nicht auf Remote sind"
                  fi
                  
                  echo "üöÄ Git push (Versuch $((RETRY_COUNT + 1))/$MAX_PUSH_RETRIES)..."
                  
                  # F√ºr die letzten 2 Versuche: Verwende --force-with-lease (sicher)
                  # --force-with-lease pusht nur, wenn Remote nicht zwischenzeitlich ge√§ndert wurde
                  if [ $RETRY_COUNT -ge $((MAX_PUSH_RETRIES - 2)) ]; then
                    echo "‚ÑπÔ∏è Verwende --force-with-lease f√ºr finalen Push-Versuch"
                    PUSH_OUTPUT=$(git push origin HEAD:main --force-with-lease 2>&1)
                  else
                    PUSH_OUTPUT=$(git push origin HEAD:main 2>&1)
                  fi
                  PUSH_EXIT_CODE=$?
                  
                  if [ $PUSH_EXIT_CODE -eq 0 ]; then
                    echo "‚úÖ Git push erfolgreich"
                    PUSH_SUCCESS=true
                    break
                  else
                    echo "$PUSH_OUTPUT"
                    RETRY_COUNT=$((RETRY_COUNT + 1))
                    if [ $RETRY_COUNT -lt $MAX_PUSH_RETRIES ]; then
                      # Pr√ºfe ob es ein "rejected" Fehler ist (Remote hat neue Commits)
                      if echo "$PUSH_OUTPUT" | grep -q "rejected\|fetch first"; then
                        WAIT_TIME=$((RETRY_COUNT * 2))
                        echo "‚ö†Ô∏è Push abgelehnt - Remote hat neue Commits"
                        echo "‚è≥ Warte ${WAIT_TIME}s und hole dann neueste √Ñnderungen..."
                        sleep $WAIT_TIME
                        # Hole neueste √Ñnderungen und versuche erneut
                        git fetch origin main 2>&1
                        git rebase origin/main 2>&1 || git merge origin/main --no-edit 2>&1 || {
                          echo "üîÑ Reset auf origin/main und neu committen..."
                          git reset --hard origin/main 2>&1
                          git add data/matches/*.json 2>&1
                          git commit -m "Update match data - $(date +'%Y-%m-%d %H:%M:%S UTC')" 2>&1
                        }
                      else
                        WAIT_TIME=$((RETRY_COUNT * 3))
                        echo "‚ö†Ô∏è Push fehlgeschlagen, warte ${WAIT_TIME}s..."
                        sleep $WAIT_TIME
                      fi
                    fi
                  fi
                done
                
                if [ "$PUSH_SUCCESS" = false ]; then
                  echo "‚ùå Git push fehlgeschlagen nach $MAX_PUSH_RETRIES Versuchen"
                  echo "‚ö†Ô∏è Der n√§chste Workflow-Lauf wird es erneut versuchen"
                  exit 1
                fi
              else
                echo "‚ÑπÔ∏è Keine √Ñnderungen zum Committen"
              fi
            else
              echo "‚ö†Ô∏è Git add fehlgeschlagen"
              exit 0  # Nicht kritisch, wenn keine Dateien hinzugef√ºgt werden k√∂nnen
            fi
          else
            echo "‚ö†Ô∏è Keine JSON-Dateien in data/matches gefunden"
            echo "‚ÑπÔ∏è M√∂glicherweise hat der Scraper keine Daten erzeugt"
            exit 0  # Nicht kritisch, wenn keine Dateien vorhanden sind
          fi

